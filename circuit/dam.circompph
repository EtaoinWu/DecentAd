include "../deps/circomlib/circuits/comparators.circom";
include "../deps/circomlib/circuits/gates.circom";


#include "setup.h"

include "../deps/circomlib/circuits/eddsamimc.circom";
include "../deps/circomlib/circuits/mimc.circom";

#include "base.circomh"

#define VERIFIER EdDSAMiMCVerifier
#define HASHER(n) MyHash(n)

template MyHash(n) {
  signal input in[n];
  signal output out;
  component c = MultiMiMC7(n, 91);
  c.k <== 0;
  for (var i = 0; i < n; i++) {
    c.in[i] <== in[i];
  }
  c.out ==> out;
}


// get number of arguments with __NARG__
#define __NARG__(...)  __NARG_I_(__VA_ARGS__,__RSEQ_N())
#define __NARG_I_(...) __ARG_N(__VA_ARGS__)
#define __ARG_N( \
      _1, _2, _3, _4, _5, _6, _7, _8, _9,_10, \
     _11,_12,_13,_14,_15,_16,_17,_18,_19,_20, \
     _21,_22,_23,_24,_25,_26,_27,_28,_29,_30, \
     _31,_32,_33,_34,_35,_36,_37,_38,_39,_40, \
     _41,_42,_43,_44,_45,_46,_47,_48,_49,_50, \
     _51,_52,_53,_54,_55,_56,_57,_58,_59,_60, \
     _61,_62,_63,N,...) N
#define __RSEQ_N() \
     63,62,61,60,                   \
     59,58,57,56,55,54,53,52,51,50, \
     49,48,47,46,45,44,43,42,41,40, \
     39,38,37,36,35,34,33,32,31,30, \
     29,28,27,26,25,24,23,22,21,20, \
     19,18,17,16,15,14,13,12,11,10, \
     9,8,7,6,5,4,3,2,1,0

// general definition for any function name
#define _VFUNC_(name, n) name##n
#define _VFUNC(name, n) _VFUNC_(name, n)
#define VFUNC(func, ...) _VFUNC(func, __NARG__(__VA_ARGS__)) (__VA_ARGS__)
#define VCALL(func, ...) func(__VA_ARGS__)
#define JOIN(name, n) name##n
#define JELEM(name, n) name.n

#define COMBx(prefix, suffix, name, joiner, x0) \
    prefix name##x0 suffix
#define COMB6(prefix, suffix, name, joiner, delim, x0) \
    COMBx(prefix, suffix, name, joiner, x0)
#define COMB7(prefix, suffix, name, joiner, delim, x0, ...) \
    COMBx(prefix, suffix, name, joiner, x0) delim \
    COMB6(prefix, suffix, name, joiner, delim, __VA_ARGS__)
#define COMB8(prefix, suffix, name, joiner, delim, x0, ...) \
    COMBx(prefix, suffix, name, joiner, x0) delim \
    COMB7(prefix, suffix, name, joiner, delim, __VA_ARGS__)
#define COMB9(prefix, suffix, name, joiner, delim, x0, ...) \
    COMBx(prefix, suffix, name, joiner, x0) delim \
    COMB8(prefix, suffix, name, joiner, delim, __VA_ARGS__)
#define comb(...) VFUNC(COMB, __VA_ARGS__)

#define COMBCOMMAx(prefix, suffix, name, joiner, x0) \
    prefix name##x0 suffix
#define COMBCOMMA6(prefix, suffix, name, joiner, delim, x0) \
    COMBCOMMAx(prefix, suffix, name, joiner, x0)
#define COMBCOMMA7(prefix, suffix, name, joiner, delim, x0, ...) \
    COMBCOMMAx(prefix, suffix, name, joiner, x0), delim \
    COMBCOMMA6(prefix, suffix, name, joiner, delim, __VA_ARGS__)
#define COMBCOMMA8(prefix, suffix, name, joiner, delim, x0, ...) \
    COMBCOMMAx(prefix, suffix, name, joiner, x0), delim \
    COMBCOMMA7(prefix, suffix, name, joiner, delim, __VA_ARGS__)
#define COMBCOMMA9(prefix, suffix, name, joiner, delim, x0, ...) \
    COMBCOMMAx(prefix, suffix, name, joiner, x0), delim \
    COMBCOMMA8(prefix, suffix, name, joiner, delim, __VA_ARGS__)
#define combcomma(...) VFUNC(COMBCOMMA, __VA_ARGS__)

#define TWOPx(prefix, ll, lj1, lm, lj2, lsuf, binop, rl, rj, rsuf, x0) \
    prefix lj1(ll, lj2(lm, x0)) lsuf binop rj(rl, x0) rsuf 
#define TWOP12(prefix, ll, lj1, lm, lj2, lsuf, binop, rl, rj, rsuf, delim, x0) \
    TWOPx(prefix, ll, lj1, lm, lj2, lsuf, binop, rl, rj, rsuf, x0)
#define TWOP13(prefix, ll, lj1, lm, lj2, lsuf, binop, rl, rj, rsuf, delim, x0, ...) \
    TWOPx(prefix, ll, lj1, lm, lj2, lsuf, binop, rl, rj, rsuf, x0) delim \
    TWOP12(prefix, ll, lj1, lm, lj2, lsuf, binop, rl, rj, rsuf, delim, __VA_ARGS__)
#define TWOP14(prefix, ll, lj1, lm, lj2, lsuf, binop, rl, rj, rsuf, delim, x0, ...) \
    TWOPx(prefix, ll, lj1, lm, lj2, lsuf, binop, rl, rj, rsuf, x0) delim \
    TWOP13(prefix, ll, lj1, lm, lj2, lsuf, binop, rl, rj, rsuf, delim, __VA_ARGS__)
#define TWOP15(prefix, ll, lj1, lm, lj2, lsuf, binop, rl, rj, rsuf, delim, x0, ...) \
    TWOPx(prefix, ll, lj1, lm, lj2, lsuf, binop, rl, rj, rsuf, x0) delim \
    TWOP14(prefix, ll, lj1, lm, lj2, lsuf, binop, rl, rj, rsuf, delim, __VA_ARGS__)
#define twop(...) VFUNC(TWOP, __VA_ARGS__)
#define meta_new(type,x,array,...) comb(signal type,array,x,JOIN,;,__VA_ARGS__)
#define meta_assign(comp,pref,larr,pk,rarr,...) twop(,comp,JELEM,pref,JOIN,larr,<==, pk, JOIN, rarr, ;, __VA_ARGS__)
#define meta_of(x, arr, ...) combcomma(,arr,x,JOIN,,__VA_ARGS__)

#define pubkey_struct Ax,Ay
#define new_pubkey(...) meta_new(__VA_ARGS__, pubkey_struct)
#define assign_pubkey(...) meta_assign(__VA_ARGS__, pubkey_struct)
#define pubkeys_of(...) meta_of(__VA_ARGS__, pubkey_struct)
#define pubkey_of(x) pubkeys_of(x,)

#define signature_struct R8x, R8y, S
#define new_signature(...) meta_new(__VA_ARGS__, signature_struct)
#define assign_signature(...) meta_assign(__VA_ARGS__, signature_struct)
#define signatures_of(...) meta_of(__VA_ARGS__, signature_struct)
#define signature_of(x) signatures_of(x,)

// two signature represents the same item
template dam_diffusion() {
  new_pubkey(input, self, );
  new_pubkey(input, parent, );
  new_signature(input, self_sig, );
  new_signature(input, parent_sig, );
  signal input seller;
  signal input item;
  signal output msg;
  
  component input_hasher = HASHER(3);
  input_hasher.in[0] <== 1;
  input_hasher.in[1] <== seller;
  input_hasher.in[2] <== item;
  input_hasher.out ==> msg;

  component self_verifier = VERIFIER();  
  self_verifier.enabled <== 1;
  assign_pubkey(self_verifier, , , self, );
  assign_signature(self_verifier, , , self_sig, );
  self_verifier.M <== msg;

  component parent_verifier = VERIFIER();
  parent_verifier.enabled <== 1;
  assign_pubkey(parent_verifier, , , parent, );
  assign_signature(parent_verifier, , , parent_sig, );
  parent_verifier.M <== msg;

  component parent_self_different_Ax = IsEqual();
  component parent_self_different_Ay = IsEqual();
  parent_self_different_Ax.in[0] <== selfAx;
  parent_self_different_Ax.in[1] <== parentAx;
  
  parent_self_different_Ay.in[0] <== selfAy;
  parent_self_different_Ay.in[1] <== parentAy;
  parent_self_different_Ax.out * parent_self_different_Ay.out === 0;
}

#define BIT_RANGE_VAR(v, e, name) \
    bit_range_##name = bit_range(BID_BITS); \
    bit_range_##name.in <== v; \
    bit_range_##name.enabled <== e

template dam_gather(width) {
  new_pubkey(input, self, );
  new_pubkey(input, child, [width]);
  signal input child_enabled[width];
  signal input childmax[width];
  signal input selfbid;
  signal input selfmax;
  new_signature(input, self_sig, );
  new_signature(input, child_sig, [width]);

  component BIT_RANGE_VAR(selfbid, 1, selfbid);
  component BIT_RANGE_VAR(selfmax, 1, selfmax);
  component BIT_RANGE_VAR(selfmax - selfbid, 1, self_range);
  component bit_range_childmax[width];
  component bit_range_child_range[width];

  for (var i = 0; i < width; i++) {
    BOOL(child_enabled[i]);
    if (i > 0) {
      (1 - child_enabled[i-1]) * (child_enabled[i]) === 0;
    }
    childmax[i] * (1 - child_enabled[i]) === 0;
    BIT_RANGE_VAR(childmax[i], child_enabled[i], childmax[i]);
    BIT_RANGE_VAR(selfmax - childmax[i], child_enabled[i], child_range[i]);
  }

  component selfmax_in_array = in_array(width + 1);
  selfmax_in_array.arr[width] <== selfbid;
  for (var i = 0; i < width; i++) {
    selfmax_in_array.arr[i] <== childmax[i];
  }
  selfmax_in_array.x <== selfmax;

  component up_hasher = HASHER(2);
  component up_verifier = VERIFIER();
  up_hasher.in[0] <== 2;
  up_hasher.in[1] <== selfmax;
  up_hasher.out ==> up_verifier.M;
  up_verifier.enabled <== 1;
  assign_pubkey(up_verifier, , , self, );
  assign_signature(up_verifier, , , self_sig, );

  component down_hasher[width];
  component down_verifier[width];
  for (var i = 0; i < width; i++) {
    down_hasher[i] = HASHER(2);
    down_verifier[i] = VERIFIER();
    down_hasher[i].in[0] <== 2;
    down_hasher[i].in[1] <== childmax[i];
    down_hasher[i].out ==> down_verifier[i].M;
    down_verifier[i].enabled <== child_enabled[i];
    assign_pubkey(down_verifier[i], , , child, [i]);
    assign_signature(down_verifier[i], , , child_sig, [i]);
  }
}

template dam_scatter(width) {
  new_pubkey(input, self, );
  new_pubkey(input, parent, );
  signal input child_enabled[width];
  signal input childmax[width];
  signal input selfbid;
  signal input selfmax;
  signal input parentoffer;
  signal input selfoffer;
  new_signature(input, self_sig, );
  new_signature(input, parent_sig, );

  component BIT_RANGE_VAR(parentoffer, 1, parentoffer);
  component BIT_RANGE_VAR(selfoffer, 1, selfoffer);

  component selfoffer_second_max = kth_in_array(width + 2, BID_BITS);
  selfoffer_second_max.x <== selfoffer;
  selfoffer_second_max.k <== 1;
  for (var i = 0; i < width; i++) {
    selfoffer_second_max.arr[i] <== childmax[i];
  }
  selfoffer_second_max.arr[width] <== selfbid;
  selfoffer_second_max.arr[width + 1] <== parentoffer;
  
  component self_hasher = HASHER(2);
  signal self_hash;
  self_hasher.in[0] <== 3;
  self_hasher.in[1] <== selfoffer;
  self_hasher.out ==> self_hash;
  
  component parent_hasher = HASHER(2);
  signal parent_hash;
  parent_hasher.in[0] <== 3;
  parent_hasher.in[1] <== parentoffer;
  parent_hasher.out ==> parent_hash;

  component self_verifier = VERIFIER();  
  self_verifier.enabled <== 1;
  assign_pubkey(self_verifier, , , self, );
  assign_signature(self_verifier, , , self_sig, );
  self_verifier.M <== self_hash;

  component parent_verifier = VERIFIER();
  parent_verifier.enabled <== 1;
  assign_pubkey(parent_verifier, , , parent, );
  assign_signature(parent_verifier, , , parent_sig, );
  parent_verifier.M <== parent_hash;
}

